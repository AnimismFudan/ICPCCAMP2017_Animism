# Problem A

## 题解

​	根据balabala之光路用的时间最短原理，沿着光路走就可以了，问题在于初始入射角，发现角度与最终到达位置单调，所以二分就可以了。

#Problem B

##题意

​	给定两个字符串，求最长公共子序列
​	多组数据
​	|A| <= 1e6 |B| <= 1e3
​	sigma(|A|) <= 1e7 sigma(|B|) <= 3e5
​	
##题解

​	突破口在于|B|非常小
​	定义f[i][j]为B中匹配到第i位，答案为j，在A中最左侧的可行匹配位置（显然越靠左越优）
​	暴力预处理Next[|A|][26]数组表示A中每个位置下一个某个字符的出现位置
​	利用Next数组更新f[i][j]
​	总复杂度O(30 * 1000 * 1000 + 26 * 1e7)
​	没被卡真是太好了……
​	
#Problem C

##题意

​	给定若干(a,b)形式的多米诺骨牌，将其摆放至平面，要求同一数字的部分必须形成一个（四连通）连通块。
N <= 50
​	
##题解

​	将连通块当做点，骨牌当做边，由于N > 4的完全图不是平面图，因此N > 4时无解
​	N <= 4时手工构造
​	胖子的构造还是很厉害的…

# Problem D

## 题解

​	套路博弈题目。

​	问题在于有的状态可能会出现环，所以我们不能递归正推。

​	考虑从已知的局面入手，倒推，不断去更新能更新的局面，直到不能更新位置，没有被确定的局面即是平局，其余的局面胜负局已定。

​	说起来容易但是我赛场上写挂了，还是有写细节的。
​	

#Problem E

##题意

​	你在数轴上移动，初始位置0，每秒可以左右移动一格，也可以不动。
​	有N个时刻，你不能留在数轴上的某个区间内。
​	Q个询问，问某个时刻你能否存在于数轴上的某个位置
​	N <= 200000
​	Q <= 200000
​	数字范围 正负1e9
​	
##题解

​	数据结构题。用set维护区间，用另一个set（其实只起了可指定位置删除的堆的作用，下称其堆）维护区间发生合并的时刻。按时间离线。	
​	不能留在数轴上的某个区间内，即是将某块区间抠掉，set查询到可行位置后暴力删除，同时更新堆。
​	询问能否存在数轴上的某个位置，即是询问是否存在某个区间包含该点。
​	麻烦的地方在于维护set的同时要更新堆，以及区间长度随时间发生变化，极易写错。
​	复杂度O(NlogN)

# Problem F

## 题解

​	各种乱搞，三分套三分，模拟退火，爬山，都可以。

# Problem G

## 题解

​	分析后发现我们要处理的是一个卷积的n次幂的问题(求$(2x-1)^n$)，用类似于快速幂的方法，再用FFT即可。

#Problem H

##题意

​	给定一棵树，你从S出发，要走到一个指定点T。你不知道哪个点是T，当你进入T后才会得知已经到达T。此外，存在一个点M，当你进入点M后，就会得知目的地T。
​	问最优策略下，最坏情况要移动几次可以到达T
N <= 2e5

##题解

​	考虑不动脑子的情况，无脑走到M，再移动到T。答案为S到M的距离，再加上M为一端的最长链（即M为根的树的最深层数）
​	如果M为根的树的最深层数不变，就不可能从之前S到M的移动中收益。
考虑如果我们之前就将最深层数的点全部遍历，那么就可以将M出发的代价部分减少一。相对的，S到M之前的移动会增加相应的代价。
​	遍历部分的代价，其实就是将其到根M的路径上的点全部选择（不重复选），每多选择一个点就增加1的代价。同时，S到M的路径上的点默认已经被选择。由于每个点只会被选择一次，复杂度O(N)
这样枚举深度，就可以得到最优解
​	
# Problem K

## 题解

​	对T串和逆序串分别建后缀自动机SAMA,SAMB，将串S的前缀在后缀自动机上SAMA上跑，将串S的后缀在后缀自动机SAMB上跑。

​	设S的长度为n，对于某个i，我们只需要找到S[1..i]在T上匹配了哪些位置，以及S[i+2,n]在S上匹配了哪些位置，最后取位置的交。

​	我们发现，对于两种匹配位置的集合，正好是对应的sam的parent树dfs上的一段区间。那么把两个dfs序一个看成横坐标另外一个看成纵坐标，就相当于求一个矩形内的点的个数，这个可以用主席树或者扫描线解决。

#Problem L

##题意

​	长度为N的序列，每次从中选择一个数取出加到答案中，同时剩余数字减一（直到为0）。最大化答案。
N <= 1e5

##题解

贪心，从大到小取即可。（减到0肯定更优）
​	
