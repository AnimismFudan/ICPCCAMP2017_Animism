#Problem B

##题意
	
	给定两个字符串，求最长公共子序列
	多组数据
	|A| <= 1e6 |B| <= 1e3
	sigma(|A|) <= 1e7 sigma(|B|) <= 3e5
	
##题解
	
	突破口在于|B|非常小
	定义f[i][j]为B中匹配到第i位，答案为j，在A中最左侧的可行匹配位置（显然越靠左越优）
	暴力预处理Next[|A|][26]数组表示A中每个位置下一个某个字符的出现位置
	利用Next数组更新f[i][j]
	总复杂度O(30 * 1000 * 1000 + 26 * 1e7)
	没被卡真是太好了……
	
#Problem C

##题意

	给定若干(a,b)形式的多米诺骨牌，将其摆放至平面，要求同一数字的部分必须形成一个（四连通）连通块。
	N <= 50
	
##题解
	
	将连通块当做点，骨牌当做边，由于N > 4的完全图不是平面图，因此N > 4时无解
	N <= 4时手工构造
	胖子的构造还是很厉害的…
	
#Problem E

##题意

	你在数轴上移动，初始位置0，每秒可以左右移动一格，也可以不动。
	有N个时刻，你不能留在数轴上的某个区间内。
	Q个询问，问某个时刻你能否存在于数轴上的某个位置
	N <= 200000
	Q <= 200000
	数字范围 正负1e9
	
##题解

	数据结构题。用set维护区间，用另一个set（其实只起了可指定位置删除的堆的作用，下称其堆）维护区间发生合并的时刻。按时间离线。
	不能留在数轴上的某个区间内，即是将某块区间抠掉，set查询到可行位置后暴力删除，同时更新堆。
	询问能否存在数轴上的某个位置，即是询问是否存在某个区间包含该点。
	麻烦的地方在于维护set的同时要更新堆，以及区间长度随时间发生变化，极易写错。
	复杂度O(NlogN)

#Problem E

##题意

	给定一棵树，你从S出发，要走到一个指定点T。你不知道哪个点是T，当你进入T后才会得知已经到达T。此外，存在一个点M，当你进入点M后，就会得知目的地T。
	问最优策略下，最坏情况要移动几次可以到达T
	N <= 2e5

##题解
	
	考虑不动脑子的情况，无脑走到M，再移动到T。答案为S到M的距离，再加上M为一端的最长链（即M为根的树的最深层数）
	如果M为根的树的最深层数不变，就不可能从之前S到M的移动中收益。
	考虑如果我们之前就将最深层数的点全部遍历，那么就可以将M出发的代价部分减少一。相对的，S到M之前的移动会增加相应的代价。
	遍历部分的代价，其实就是将其到根M的路径上的点全部选择（不重复选），每多选择一个点就增加1的代价。同时，S到M的路径上的点默认已经被选择。由于每个点只会被选择一次，复杂度O(N)
	这样枚举深度，就可以得到最优解
	
#Problem L

##题意

	长度为N的序列，每次从中选择一个数取出加到答案中，同时剩余数字减一（直到为0）。最大化答案。
	N <= 1e5

##题解

	贪心，从大到小取即可。（减到0肯定更优）
	
