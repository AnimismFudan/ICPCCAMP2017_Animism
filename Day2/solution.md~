#Problem F

##题意
给定一个大矩形，大矩形内（不会超出）有若干（可能相交的）小矩形，小矩形左侧或右侧必然与大矩形重叠。每个小矩形有一定的价值Vi。取出若干小矩形，要求互不相交（边可重叠），最大化价值和。
1 <= N <= 2000 矩形边长 <= 1e6，Vi <= 1e6
	
##题解

（为避免某一侧没有矩形的情况，在最上端添加两个微小矩形，价值为0，初始必取）
将矩形按上边界递增排序，dp[i][j]表示左侧最下方矩形取i，右侧最下方矩形取j，得到的最大价值
转移时注意几点：
1） 如果要从dp[k][j]转移到dp[i][j]，则i的上边界必须大于j的上边界
如果要从dp[i][k]转移到dp[i][j]，则j的上边界必须大于i的上边界
即永远只能选择偏下的矩形进行转移，避免左侧连跳几次，右侧连跳几次，其实中间过程不合法的情况
2）将可行转移情况全部列出后，很多条件都只和i、j有关，与k有关的条件只有一维，可以用树状数组简单维护
复杂度O(N^2logN)
附上暴力代码F_2.cpp

#Problem J

##题意

构造一个N个点的无向图，要求其点连通度为K，并存在一个哈密顿回路，或者判断无解
3 <= N <= 100
1 <= K <= N - 2

##题解
	
显然K = 1无解
哈密顿回路等价于一个环，先构造好，之后在环上加边
考虑N为偶数，构造完哈密顿图后每个点度数为2，K也为2
现在枚举step = 2，每次将所有点x与x + step（模N意义上）连边，连完之后每个点都有4个度，显然此时连通度<=4，显然图看起来也很稳固（→_→赛场上没有仔细证明，但看起来确实是最稳的连边方法）。所以此时连通度 = 4
继续增加step到3，继续连边，每个点的度数增加了2，连通度也增加了2
重复操作，直至度数等于K，或者K - 1
如果度数等于K，就做完了这道题
如果度数等于K - 1，那么我们将每个点x与x + N / 2连边，由于N为偶数，因此只增加了N/2条边，每个点度数增加1，等于K。
（很显然我们之前没有连过x与x + N / 2）
类似的，N为奇数，K为偶数时，可以类似的得到解	
但N为奇数，K为奇数时，最后一条边因为不能完全对称，不能完全按照之前的套路解决。
稍作思考，图的总度数为偶数，但N*K是奇数，因此无论如何都不可能使每个点的度数都为K。
这样就很好做了，先无视第N个点，按偶数方案连边，再将第N个点随便连一条边即可。

