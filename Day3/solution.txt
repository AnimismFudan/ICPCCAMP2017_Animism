#Problem A

#题意

	给定一个有N个元素的数列{Ai}，系统选择一个整数M，随机生成整数K(0 <= K < M)，计算得到{Bi}，Bi = (Ai + K) % M，并将{Bi}排序。
	现在给定{Ai}和{Bi}，要求计算得到M和K
	1e5 <= N <= 2e5
	1 <= Ai <= 1e18
	0 <= Bi < 1e10
	0 <= K < M <= 1e10

#题解
	
	首先由于K随机给定，因此M不会超过Bi的最大值过多。从Bi的最大值开始枚举M，一一检查
	预处理{Ai}之和S1，{Bi}之和S2，(S1 + K * N) % M = S2 % M，得到一个同余方程，解出K的若干可行解。由于M一一枚举，K的可行解不会太多（大概是N的因数balabala…吉利语）
	一一枚举Ai，在哈希表中查找对应的(Ai + K) % M是否存在于Bi，不存在就剪枝
	最后再暴力检查一次
	总之跑过去了

#Problem C

#题意
	
	一个无向图的子图是欧拉子图，当且仅当，每个点的度数都为偶数。
	给定N个点M条边的图，选择一个边导出子图，如果是欧拉子图，则对答案贡献x^2（x是边数）
	问总贡献
	1 <= N <= 2e5 0 <= M <= 2e5
	
#题解
	
	有一个结论：一张图的欧拉子图个数为2^(E-V+C) C为连通块个数，E-V+C等价于非树边数量
	x ^ 2 = x + (x * (x - 1) / 2) * 2
	即：包含某条边的欧拉子图个数 + 包含某对边的欧拉子图个数
	左侧部分很好求，计算出所有可能在欧拉子图内的边（非树边和被非树边包围的树边），选择其中任一条边，（非树边）就必须选择其对应的欧拉子图，或者（树边）就必须使包含其的欧拉子图数量为奇数（正好一半）。单条边贡献为2 ^ (E-V+C - 1)，总贡献乘上可行的边数
	右侧部分，考虑两条边，如果这两条边被强制选择，即相当于将着两条边删去，从剩下的图中选择欧拉子图，再将两条边对应的欧拉子图重新添回去。由于欧拉子图上的边不可能为割边，因此两条边同时被删去后，连通块个数C可能增加1。
	有一个简单的判断方法，对所有非树边随机一个longlong以内的值，树边的值，等于覆盖其的非树边的值的异或和。如果两条边的值相同，则删除这两条边会产生一个新的连通块
	求每条树边的异或和可以扫描一次得到。这样就得到了两条边对答案的贡献。
	
#Problem D

#题意

	给定一个N,M的方阵，方阵内每条边有权值，每个元素Cij有一个0~4的值。
	你可以选择一些边，但需要满足一下条件：
	1）Cij等于包围它的四条边被选择的条数、
	2）每个节点上的四条边可以被选择0条或2条
	3）每个节点处如果有两条边，则不能处于同一直线上（必须拐弯）
	4）要求使边权和最大
	N,M <= 100
	
#题解

	这道题的方案是唯一的……
	左上角的元素C11左侧和上侧的两条边，可以通过C11的值直接得到。（C11为4时全取，否则全空）
	然后可以递推得到C1j除下侧外的所有边。
	然后可以递推得到Cij除下侧外的所有边。
	然后补上底部的边即可
	（通过之前边的选取与否，可以判断绝大多数情况，当无法判断是，可以直接通过C(i-1,j)的约束，得到上侧边是否被取，从而得到解）
	需要验证解是否合法

#Problem F

#题意
	
	给定一个长度为N的1~N排列，将其组成完全二叉树，你可以取出一个子图（要求连通，即形成一棵树），将子树内元素（记为K个）排序得到{Wi}，他的A-中位数等于W((K - A + 1) / 2)。
	对于每个A，求出最大的A-中位数
	1 <= N <= 2e5

#题解
	
	i能成为某棵子树的A-中位数，当且仅当，X - Y >= A （记这棵子树中比i大的元素个数为X，比i小的元素个数为Y）
	那么就是最大化X - Y，即可得到A的最大取值范围
	用Dp预处理得到以点x为根，最大化 {比1大的点个数 - 比1小的点个数}
	从1开始枚举i，i增加1后，仅有两个数字的贡献（i和i+1）被修改，它们到根的路径上的所有点的dp都会受影响
	但由于完全二叉树树高为log的性质，直接暴力一波即可成功维护
	由于我们dp时以点x为根，未考虑向上走的情况，因此更新答案时也要向上维护答案，可以用类似转根的方式维护。

#Problem I

#题意

	A和B在一棵树上玩游戏，两人起始位置不同，A先手，B后手，依次移动到相邻点，执行K次（每个人的移动都算一次）。A每次移动都能占领所在位置，B同理。同一位置被多次占据，归最后一次占据者所有。A要最大化（A占领的点 - B占领的点），B要最小化这个值。
	2 <= N <= 2e5
	1 <= Q <= 2e5

#题解
	
	玩几次可知，如果A想踩尽量多的点，B可以选择互踩（取决于K和AB之间的距离），也可以跑路（取决于两点之间是否存在一条长度足够长的链）
	跑路当且仅当，你可以使两者走过的路线完全不重合，可以使答案变优。否则还是选择互踩
	互踩能够得到的结果直接分类讨论得到
	尝试跑路，不妨假设A走k1步，B走k2步，且B选择跑路，那么A一定会朝着B前进k1步，这些点都是B不能经过的。而查找到这个分界点可以通过倍增O(logn)得到。因此问题转化为求一棵子树内以某个点为根得到的最长链。最长链的端点显然是直径的某一端。因此预处理树形dp维护子树最长链和直径，转根得到所有子树的解。询问时查询距离即可。
	复杂度O(NlogN)