# Problem A

## 题解

​	设$f_{i,j}$表示第i-1个数和第i个数已经确定，且知道第i个数>第i-1个数，且第i个数值为j的方案数。

​	设$g_{i,j}$表示第i-1个数已经确定，而且要求第i个数<=第i-1个数，且第i-1个数值为j的方案数。

​	利用前缀和可以做到转移O(1)

# Problem B

## 题解

​	枚举出所有可能的路近状态所构成的图案形状，然后计算每个形状分别出现了多少次，再乘上这个形状下可能出现的不同路径方案（六元组的个数）。统计之后输出答案。

#Problem C

##题意

​	给定N个点M条边的无向图，选择任一非空子集，如果该子集连通，则称该子集合法
​	问合法子集在模2意义下的个数
​	1 <= N <= 50
​	0 <= M <= N * (N - 1) / 2

##题解

​	我们考虑这样一个问题：
​	给定N个点M条边的无向图，选择任一非空子集，记该子集连通块个数为K，则对答案贡献2^K，统计贡献和在模4意义下的答案
​	可以注意到，K>=2 时，(2^K)%4=0；K=1 时，对答案贡献2。因此总贡献模4后一定为0或2，将这个值除2后即可得到原问题的解。
​	再考虑2^K的意义，等价于对每个连通块染黑色或白色（同一个块内的点染同一个颜色），得到的方案数因此问题转化为，对每个点进行黑白灰染色（灰色表示不取该点），合法的方案数模4（合法即相邻的两个点不能分别为黑白色，否则与同一连通块内染同色矛盾）。
​	状态压缩动态规划
​	转移时使用dfs查询合法方案，可以减少O(N)的复杂度
​	总复杂度O(N*3^N)

# Problem D

## 题解

​	其实就是一个多重背包问题，但是由于可行的方案太大，考虑将它们根据所有价值的最小公倍数L划分，会发现在所有的可行方案都是在1..nL(叉姐说可以优化到2L)为首项，公差为L的等差数列，最后一项为小于sum的最大值。这样就只要用多重背包处理1..nL的数据，然后根据L的公差进行累加，注意去重。

# Problem E

## 题解

​	首先将权值与父亲差分，每个子问题转化成所有公共祖先的权值的和。

​	之后从1到n边更新边查，每次更新一个点时，将这个点的所有父亲(包括自身)的sum值加上原来差分后的权值，查询的时候询问这个点到根的路径上的sum值之和，用树链剖分可以解决。

# Problem F

## 题解

​	对所有的$0\leq C < n$，可以$O(n^4)$预处理$E(t,u)$(在t时刻u点上的期望人数)对$E(t+C,v)$的贡献。

​	然后分块：现在已知$E(0,*)$，可以用预处理的矩阵，$O(n^3)$地得到$E(1,n),E(2,n)...E(n,n)$，同时，可以$O(n^3)$地得到$E(n,*)$，那么块内的答案就做完了。之后类似的处理，复杂度$O(T/n\times n^3)=O(T\times n^2)$

​	对于多个人，中途暴力加入即可。

#Problem G

##题意

​	给定常量M*M矩阵A、B，且给出以下递推式
​	M(0) = A
​	M(i) = 顺序乘积(M(j)) * B {Ci <= j < i}
​	Ci递增
​	求出M(N)
​	M <= 5 N <= 1000000

##题解

​	解法一：
​	从左向右扫描，利用并查集思想，将 i - 1 到 i 连边，边权为M(i - 1)，每次即求Ci到根路径上的权值积，利用	路径压缩减少复杂度。
​	总复杂度O(N*log(N)*(M^3))，log(N)为并查集复杂度

​	解法二：
​	由于需要维护的数据结构是个单调队列，但矩阵乘法不一定满足除法（可能无逆元），因此将队列拆分成两个栈，分别维护中间向两侧的后/前缀乘积Ci增加，即后缀乘积栈弹出一个元素（不需要矩阵乘法）i增加，即前缀乘积栈增加一个元素（需要一次矩阵乘法）
​	当且仅当，后缀乘积栈被弹空后，我们将前缀乘积栈清空并重构成后缀乘积栈。
​	这样每个元素进队一次，重构一次，弹出一次，每次都消耗O(M^3)或O(1)的复杂度
总复杂度O(N*(M^3))

# Problem H

## 题解

​	通过打表前10个元素，找出规律$f(x) = 2f(x-1) + f(x-3)+2$，然后令$g(x) = f(x) + 1$得$g(x) = 2g(x-1) + g(x-3)$，用矩阵乘法加速。

#Problem K

##题意

​	给定区域赛和Final的出线规则，计算出线队伍的可能方案数
N <= 200000 M <= 200000

##题解

​	简单题
​	扫描Final的出线人数，维护区域赛每个排名的有效队伍数，利用树状数组维护前缀和即可
通过控制求和区间来避免重复
