#Problem A

##题意

给定N个点M条边的无向图，选择任一非空子集，如果该子集连通，则称该子集合法
问合法子集在模2意义下的个数
1 <= N <= 50
0 <= M <= N * (N - 1) / 2

##题解

我们考虑这样一个问题：
给定N个点M条边的无向图，选择任一非空子集，记该子集连通块个数为K，则对答案贡献2^K，统计
贡献和在模4意义下的答案
可以注意到，K>=2 时，(2^K)%4=0；K=1 时，对答案贡献2。因此总贡献模4后一定为0或2，将这个值除2后即可得到原问题的解。
再考虑2^K的意义，等价于对每个连通块染黑色或白色（同一个块内的点染同一个颜色），得到的方案数
因此问题转化为，对每个点进行黑白灰染色（灰色表示不取该点），合法的方案数模4（合法即相邻的两个点不能分别为黑白色，否则与同一连通块内染同色矛盾）。
状态压缩动态规划
转移时使用dfs查询合法方案，可以减少O(N)的复杂度
总复杂度O(N*3^N)

#Problem G

##题意

给定常量M*M矩阵A、B，且给出以下递推式
M(0) = A
M(i) = 顺序乘积(M(j)) * B {Ci <= j < i}
Ci递增
求出M(N)
M <= 5 N <= 1000000

##题解

解法一：
从左向右扫描，利用并查集思想，将 i - 1 到 i 连边，边权为M(i - 1)，每次即求Ci到根路径上的权值积，利用路径压缩减少复杂度。
总复杂度O(N*log(N)*(M^3))，log(N)为并查集复杂度

解法二：
由于需要维护的数据结构是个单调队列，但矩阵乘法不一定满足除法（可能无逆元），因此将队列拆分成两个栈，分别维护中间向两侧的后/前缀乘积
Ci增加，即后缀乘积栈弹出一个元素（不需要矩阵乘法）
i增加，即前缀乘积栈增加一个元素（需要一次矩阵乘法）
当且仅当，后缀乘积栈被弹空后，我们将前缀乘积栈清空并重构成后缀乘积栈。
这样每个元素进队一次，重构一次，弹出一次，每次都消耗O(M^3)或O(1)的复杂度
总复杂度O(N*(M^3))

#Problem K

##题意

给定区域赛和Final的出线规则，计算出线队伍的可能方案数
N <= 200000 M <= 200000

##题解

	简单题
	扫描Final的出线人数，维护区域赛每个排名的有效队伍数，利用树状数组维护前缀和即可
	通过控制求和区间来避免重复
